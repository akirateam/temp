# tasks/process_single_resource_comparison.yml
- name: "Setup facts for {{ current_resource_def.kind }} comparison"
  ansible.builtin.set_fact:
    resource_file_name_comp: "{{ (current_resource_def.filename_override | default(current_resource_def.kind | lower + '.yml')) }}"
    file_path_before: "{{ snapshot_dir_before }}/{{ (current_resource_def.filename_override | default(current_resource_def.kind | lower + '.yml')) }}"
    file_path_after: "{{ snapshot_dir_after }}/{{ (current_resource_def.filename_override | default(current_resource_def.kind | lower + '.yml')) }}"
    current_comp_result: {}
    # Inicializa resource_diff_text para evitar erros se não for definido
    resource_diff_text: "Nenhum diff gerado ou aplicável."


- name: "Check existence of {{ current_resource_def.kind }} snapshot files"
  ansible.builtin.stat:
    path: "{{ item }}"
  loop:
    - "{{ file_path_before }}"
    - "{{ file_path_after }}"
  register: resource_files_stat

- name: "Determine existence flags for {{ current_resource_def.kind }}"
  ansible.builtin.set_fact:
    before_exists: "{{ resource_files_stat.results[0].stat.exists }}"
    after_exists: "{{ resource_files_stat.results[1].stat.exists }}"

- name: "Process comparison for {{ current_resource_def.kind }}"
  block:
    - name: "Handle ADDED: {{ current_resource_def.kind }}"
      when: not before_exists and after_exists
      ansible.builtin.set_fact:
        current_comp_result:
          kind: "{{ current_resource_def.kind }}"
          state: "Adicionado"
          file: "{{ resource_file_name_comp }}"
          diff: "Recurso não existia no snapshot 'antes_upgrade'."

    - name: "Handle REMOVED: {{ current_resource_def.kind }}"
      when: before_exists and not after_exists
      ansible.builtin.set_fact:
        current_comp_result:
          kind: "{{ current_resource_def.kind }}"
          state: "Removido"
          file: "{{ resource_file_name_comp }}"
          diff: "Recurso não encontrado no snapshot 'depois_upgrade'."

    - name: "Handle UNCHANGED or MODIFIED: {{ current_resource_def.kind }}"
      when: before_exists and after_exists
      block:
        - name: "Slurp content of {{ current_resource_def.kind }} files for comparison"
          ansible.builtin.slurp:
            src: "{{ item }}"
          loop:
            - "{{ file_path_before }}"
            - "{{ file_path_after }}"
          register: slurped_files
          ignore_errors: true

        - name: Decode slurped content
          ansible.builtin.set_fact:
            content_before: "{{ slurped_files.results[0].content | default('') | b64decode if not slurped_files.results[0].failed | default(true) else 'ERRO_LEITURA_ANTES' }}"
            content_after: "{{ slurped_files.results[1].content | default('') | b64decode if not slurped_files.results[1].failed | default(true) else 'ERRO_LEITURA_DEPOIS' }}"

        - name: "Check if {{ current_resource_def.kind }} is MODIFIED (and readable)"
          when: 
            - content_before != 'ERRO_LEITURA_ANTES'
            - content_after != 'ERRO_LEITURA_DEPOIS'
            - content_before != content_after # Apenas executa o diff se o conteúdo for diferente
          block:
            - name: Create temporary file for 'before' content
              ansible.builtin.tempfile:
                state: file
                prefix: "aro_diff_{{ current_resource_def.kind | lower }}_before_"
              register: temp_before_file

            - name: Write 'before' content to temporary file
              ansible.builtin.copy:
                content: "{{ content_before }}"
                dest: "{{ temp_before_file.path }}"
              when: temp_before_file.path is defined

            - name: Create temporary file for 'after' content
              ansible.builtin.tempfile:
                state: file
                prefix: "aro_diff_{{ current_resource_def.kind | lower }}_after_"
              register: temp_after_file

            - name: Write 'after' content to temporary file
              ansible.builtin.copy:
                content: "{{ content_after }}"
                dest: "{{ temp_after_file.path }}"
              when: temp_after_file.path is defined

            - name: "Generate diff for {{ current_resource_def.kind }} using Python script"
              ansible.builtin.command: >
                python {{ playbook_dir }}/scripts/custom_diff.py
                {{ temp_before_file.path | quote }}
                {{ temp_after_file.path | quote }}
                "{{ resource_file_name_comp }} (antes)"
                "{{ resource_file_name_comp }} (depois)"
              register: script_diff_output
              changed_when: false # Diffing não altera o estado
              failed_when: script_diff_output.rc != 0 # Falha se o script Python retornar erro
              when:
                - temp_before_file.path is defined
                - temp_after_file.path is defined

            - name: Set diff text from Python script output
              ansible.builtin.set_fact:
                resource_diff_text: "{{ script_diff_output.stdout if script_diff_output.rc == 0 and script_diff_output.stdout | trim != '' else ('Conteúdo diferente, mas diff vazio.' if script_diff_output.rc == 0 else 'Erro ao gerar diff com script: ' + (script_diff_output.stderr if script_diff_output.stderr else 'Sem output de erro do script.')) }}"
              when: script_diff_output is defined # Garante que a task do script rodou

            - name: Set state to Modificado
              ansible.builtin.set_fact:
                current_comp_result:
                  kind: "{{ current_resource_def.kind }}"
                  state: "Modificado"
                  file: "{{ resource_file_name_comp }}"
                  diff: "{{ resource_diff_text }}"

            # Bloco de Limpeza de Arquivos Temporários
            - name: Clean up temporary files after diff
              block:
                - name: "Clean up temporary 'before' file: {{ temp_before_file.path | default('N/A') }}"
                  ansible.builtin.file:
                    path: "{{ temp_before_file.path }}"
                    state: absent
                  when: temp_before_file.path is defined
                  ignore_errors: true # Continua mesmo se a limpeza falhar por algum motivo

                - name: "Clean up temporary 'after' file: {{ temp_after_file.path | default('N/A') }}"
                  ansible.builtin.file:
                    path: "{{ temp_after_file.path }}"
                    state: absent
                  when: temp_after_file.path is defined
                  ignore_errors: true
              always: true # Garante que a limpeza seja tentada mesmo se o diff falhar

        - name: "Mark {{ current_resource_def.kind }} as UNCHANGED (or unreadable but content matches)"
          when: 
            - content_before == 'ERRO_LEITURA_ANTES' or content_after == 'ERRO_LEITURA_DEPOIS' or content_before == content_after
          ansible.builtin.set_fact:
            current_comp_result:
              kind: "{{ current_resource_def.kind }}"
              state: "{{ 'Erro de Leitura' if content_before == 'ERRO_LEITURA_ANTES' or content_after == 'ERRO_LEITURA_DEPOIS' else 'Inalterado' }}"
              file: "{{ resource_file_name_comp }}"
              diff: "{{ 'Não foi possível ler um ou ambos os arquivos para comparação.' if content_before == 'ERRO_LEITURA_ANTES' or content_after == 'ERRO_LEITURA_DEPOIS' else '' }}"

    - name: "Handle MISSING from both snapshots: {{ current_resource_def.kind }}"
      when: not before_exists and not after_exists
      ansible.builtin.set_fact:
        current_comp_result:
          kind: "{{ current_resource_def.kind }}"
          state: "Não encontrado em ambos snapshots"
          file: "{{ resource_file_name_comp }}"
          diff: "Recurso não capturado em nenhum dos snapshots."

  always:
    - name: Aggregate comparison result for {{ current_resource_def.kind }}
      ansible.builtin.set_fact:
        comparison_results: "{{ comparison_results + [current_comp_result] if current_comp_result.kind is defined else comparison_results }}"