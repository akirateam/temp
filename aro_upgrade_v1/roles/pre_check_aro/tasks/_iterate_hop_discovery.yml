---
# Este arquivo é incluído em um loop por 02_determine_hops.yml
# Tenta encontrar UM próximo salto EUS de forma incremental.
# Modifica os fatos: iteration, simulated_current_version, simulated_current_eus_channel,
# calculated_upgrade_hops, _no_more_hops_can_be_found.

- name: "Iteração {{ iteration + 1 }} (interno simplificado): Buscando próximo salto EUS de {{ simulated_current_version }} para {{ target_aro_version }}"
  ansible.builtin.set_fact:
    next_hop_candidate: null
    hop_found_this_iteration: false # Resetar para esta iteração lógica

- name: "Filtrar e selecionar o próximo salto EUS disponível de forma incremental"
  vars:
    # live_available_updates_param é passado pelo include_tasks
    potential_hops_eval: |
      {% set candidates = [] %}
      {% for update in live_available_updates_param %}
        {# Condição 1: Versão do update > versão simulada atual #}
        {% if update.version is version(simulated_current_version, '>') %}
          {# Condição 2: Versão do update <= versão alvo final #}
          {% if update.version is version(target_aro_version, '<=') %}
            {# Condição 3: O update deve estar em um canal EUS correspondente à sua própria versão X.Y #}
            {# Ex: versão 4.14.20 deve estar associada ao canal eus-4.14 #}
            {% set update_version_major_minor = update.version.split('.')[0] + "." + update.version.split('.')[1] %}
            {% set update_eus_channel_expected = "eus-" + update_version_major_minor %}
            {% set is_in_eus_channel = false %}
            {% if 'channels' in update and update.channels is iterable %}
              {% for ch in update.channels %}
                {% if ch == update_eus_channel_expected %}
                  {% set is_in_eus_channel = true %}
                {% endif %}
              {% endfor %}
            {% endif %}
            
            {% if is_in_eus_channel %}
              {# Adiciona a versão do update à lista de candidatos #}
              {% set candidates = candidates + [update.version] %}
            {% endif %}
          {% endif %}
        {% endif %}
      {% endfor %}
      {# Ordena os candidatos por versão para pegar o próximo salto incremental mais baixo #}
      {{ candidates | sort(version=true) }}
  ansible.builtin.set_fact:
    potential_eus_hops_list: "{{ potential_hops_eval | from_yaml if potential_hops_eval else [] }}"

- name: "Selecionar o próximo salto EUS mais baixo e definir fatos da iteração"
  ansible.builtin.set_fact:
    next_hop_candidate: "{{ potential_eus_hops_list[0] if potential_eus_hops_list | length > 0 else null }}"
    hop_found_this_iteration: "{{ true if potential_eus_hops_list | length > 0 else false }}"

# --- Atualizar estado da simulação se um hop foi encontrado ---
- name: Registrar salto encontrado e atualizar simulação (interno)
  when: hop_found_this_iteration and next_hop_candidate is not none # Garante que next_hop_candidate não é null
  block:
    - ansible.builtin.debug:
        msg: "Cluster {{ cluster_name }}: Próximo salto EUS incremental encontrado de {{ simulated_current_version }} para {{ next_hop_candidate }}"
    - ansible.builtin.set_fact:
        calculated_upgrade_hops: "{{ calculated_upgrade_hops + [next_hop_candidate] }}"
        simulated_current_version: "{{ next_hop_candidate }}"
        # Atualizar o canal EUS simulado com base no canal do salto escolhido
        simulated_current_eus_channel: "{{ 'eus-' + next_hop_candidate.split('.')[0] + '.' + next_hop_candidate.split('.')[1] }}"
        # _no_more_hops_can_be_found permanece false (ou é resetado) pois um hop foi encontrado
        _no_more_hops_can_be_found: false

- name: "Definir flag se nenhum salto foi encontrado nesta iteração (para quebrar loop pai)"
  ansible.builtin.set_fact:
    _no_more_hops_can_be_found: true
  when: not hop_found_this_iteration # Se, após a filtragem, nenhum candidato válido foi encontrado

- name: "Incrementar contador de iteração (para debug e controle do loop pai)"
  ansible.builtin.set_fact:
    iteration: "{{ iteration | int + 1 }}"