---
# Vars esperadas neste include: target_hop_version, cluster_name
- name: "Obter versão atual do cluster {{ cluster_name }} antes do salto para {{ target_hop_version }}"
  kubernetes.core.k8s_info:
    kind: ClusterVersion
    api_version: config.openshift.io/v1
    name: version
  register: r_cluster_version_current_hop_pre
  retries: 3
  delay: 10

- name: Definir current_version_before_hop
  ansible.builtin.set_fact:
    current_version_before_hop: "{{ r_cluster_version_current_hop_pre.resources[0].status.desired.version }}"

- name: "INICIANDO Salto de Upgrade para: {{ target_hop_version }} em {{ cluster_name }}"
  ansible.builtin.debug:
    msg: "Cluster: {{ cluster_name }}. Iniciando processo de upgrade de {{ current_version_before_hop }} para {{ target_hop_version }}"

- name: "Pausar MCPs (worker e infra, se existir) em {{ cluster_name }}"
  kubernetes.core.k8s_patch:
    kind: MachineConfigPool
    api_version: machineconfiguration.openshift.io/v1
    name: "{{ item }}"
    definition:
      spec:
        paused: true
    retries: 3
    delay: 10
  loop:
    - worker
    # - infra # Descomente se você tiver um pool de infra dedicado relevante
  register: r_mcp_pause_status
  loop_control:
    label: "mcp-{{ item }}"

- name: "Aguardar MCPs serem efetivamente pausados em {{ cluster_name }}"
  kubernetes.core.k8s_info:
    kind: MachineConfigPool
    api_version: machineconfiguration.openshift.io/v1
    name: "{{ item.item }}" # Acessa o item do loop original do r_mcp_pause_status
  register: r_mcp_check_paused
  until: (r_mcp_check_paused.resources[0].status.conditions | selectattr('type', 'equalto', 'Paused') | first).status == 'True'
  retries: 12 # 12 * 30s = 6 minutos
  delay: 30
  loop: "{{ r_mcp_pause_status.results }}" # Itera sobre os resultados da tarefa de patch
  when: item.changed # Apenas para MCPs que foram efetivamente alterados (pausados)
  loop_control:
    label: "mcp-check-{{ item.item }}"

- name: "Health Check (Comum): Pré-Salto para {{ target_hop_version }} em {{ cluster_name }}"
  include_tasks: _common_health_check.yml
  vars:
    health_check_stage_name: "Cluster {{ cluster_name }} - Pré-Salto para {{ target_hop_version }}"

- name: Determinar canal EUS para o salto alvo ({{ target_hop_version }})
  ansible.builtin.set_fact:
    # O canal EUS é derivado da versão do salto. Ex: 4.16.50 -> eus-4.16
    target_hop_eus_channel: "eus-{{ target_hop_version.split('.')[0] }}.{{ target_hop_version.split('.')[1] }}"

- name: "Iniciar upgrade para {{ target_hop_version }} no canal {{ target_hop_eus_channel }} em {{ cluster_name }}"
  ansible.builtin.command: >
    oc adm upgrade --to={{ target_hop_version }}
    --allow-explicit-upgrade
    --allow-upgrade-with-warnings
    --force=false
    --acknowledge-critical-updates=true
    --channel={{ target_hop_eus_channel }}
  register: r_upgrade_command
  changed_when: >
    r_upgrade_command.rc == 0 and
    ('Update to {{ target_hop_version }} is already in progress' not in r_upgrade_command.stdout_lines | join(' ')) and
    ('Update to {{ target_hop_version }} is already recommended' not in r_upgrade_command.stdout_lines | join(' ')) and
    ('Update to {{ target_hop_version }} already completed' not in r_upgrade_command.stdout_lines | join(' '))
  failed_when: >
    r_upgrade_command.rc != 0 and
    ('already recommended' not in r_upgrade_command.stdout_lines | join(' ')) and
    ('already in progress' not in r_upgrade_command.stdout_lines | join(' ')) and
    ('already completed' not in r_upgrade_command.stdout_lines | join(' '))
  # Aumentar timeout se necessário para o comando oc
  # async: 300 # 5 minutos para o comando iniciar, não para o upgrade completo
  # poll: 10

- name: "Monitorar Progresso do Upgrade para {{ target_hop_version }} (CVO) em {{ cluster_name }}"
  kubernetes.core.k8s_info:
    kind: ClusterVersion
    api_version: config.openshift.io/v1
    name: version
  register: r_cv_status_hop
  until: >
    r_cv_status_hop.resources is defined and
    r_cv_status_hop.resources | length > 0 and
    r_cv_status_hop.resources[0].status.desired.version == target_hop_version and
    (r_cv_status_hop.resources[0].status.conditions | selectattr('type', 'equalto', 'Available') | first).status == 'True' and
    (r_cv_status_hop.resources[0].status.conditions | selectattr('type', 'equalto', 'Progressing') | first).status == 'False' and
    (r_cv_status_hop.resources[0].status.conditions | selectattr('type', 'equalto', 'Degraded') | first).status == 'False'
  retries: 360 # Pode levar horas. Ex: 360 retries * 60s delay = 6 horas
  delay: 60    # Verificar a cada minuto
  vars:
    ansible_command_timeout: 7200 # Timeout para esta tarefa Ansible (2 horas)

- name: "Health Check (Comum): Pós-Salto para {{ target_hop_version }} (CVO Concluído) em {{ cluster_name }}"
  include_tasks: _common_health_check.yml
  vars:
    health_check_stage_name: "Cluster {{ cluster_name }} - Pós-Salto {{ target_hop_version }} (CVO Concluído)"

- name: "Despausar MCPs em {{ cluster_name }}"
  kubernetes.core.k8s_patch:
    kind: MachineConfigPool
    api_version: machineconfiguration.openshift.io/v1
    name: "{{ item }}"
    definition:
      spec:
        paused: false
  loop:
    - worker
    # - infra
  register: r_mcp_unpause_status
  loop_control:
    label: "mcp-unpause-{{ item }}"

- name: "Aguardar MCPs (worker/infra) concluírem a atualização após despausar em {{ cluster_name }}"
  kubernetes.core.k8s_info:
    kind: MachineConfigPool
    api_version: machineconfiguration.openshift.io/v1
    name: "{{ item.item }}" # Acessa o item do loop original do r_mcp_unpause_status
  register: r_mcp_status_updated
  until: >
    r_mcp_status_updated.resources is defined and
    r_mcp_status_updated.resources | length > 0 and
    r_mcp_status_updated.resources[0].status.updatedMachineCount == r_mcp_status_updated.resources[0].status.machineCount and
    (r_mcp_status_updated.resources[0].status.conditions | selectattr('type', 'equalto', 'Updating') | first).status == 'False' and
    (r_mcp_status_updated.resources[0].status.conditions | selectattr('type', 'equalto', 'Degraded') | first).status == 'False' and
    ( (r_mcp_status_updated.resources[0].status.conditions | selectattr('type', 'equalto', 'Paused') | first).status == 'False' or
      not (r_mcp_status_updated.resources[0].status.conditions | selectattr('type', 'equalto', 'Paused') | list) )
  retries: 240 # Ex: 240 retries * 60s delay = 4 horas
  delay: 60
  loop: "{{ r_mcp_unpause_status.results }}"
  when: item.changed # Apenas para MCPs que foram efetivamente alterados (despausados)
  loop_control:
    label: "mcp-wait-{{ item.item }}"
  vars:
    ansible_command_timeout: 7200 # Timeout para esta tarefa Ansible (2 horas)

- name: "Health Check (Comum): Pós-Salto para {{ target_hop_version }} (MCPs Concluídos) em {{ cluster_name }}"
  include_tasks: _common_health_check.yml
  vars:
    health_check_stage_name: "Cluster {{ cluster_name }} - Pós-Salto {{ target_hop_version }} (MCPs Concluídos)"

- name: "Sumário do Salto {{ target_hop_version }} para {{ cluster_name }}"
  ansible.builtin.debug:
    msg:
      - "Cluster: {{ cluster_name }}"
      - "Salto de upgrade para {{ target_hop_version }} concluído."
      - "Versão anterior ao salto: {{ current_version_before_hop }}"
      - "Versão atual após salto (CVO): {{ r_cv_status_hop.resources[0].status.desired.version }}"
      - "Status: OK"